# 리타겟팅 이동 기능 null 값 오류 해결 과정

## 문제 발생
- `customer_name` 컬럼에 `null` 값이 들어가서 `NOT NULL` 제약 조건 위반 오류 발생
- 20번 이상 동일한 오류 반복
- 로컬에서는 정상 작동하지만 Railway 배포 환경에서 지속적으로 실패

## 문제 원인 분석

### 1. 코드 구조 문제
- 중복된 null 체크 로직이 여러 곳에 흩어져 있음
- 변수 재할당 과정에서 값이 손실될 가능성
- 트랜잭션 내부와 외부에서 값 처리 로직이 분리되어 있어 일관성 부족

### 2. 배포 문제
- 빌드된 코드가 최신 코드를 반영하지 않을 수 있음
- TypeScript 컴파일 과정에서 변수 스코프 문제 가능성

### 3. 방어 로직 부족
- 여러 단계의 null 체크에도 불구하고 어딘가에서 null이 전달됨
- 검증 로직이 산재되어 있어 누락 가능성

## 해결 방법

### 1. null-safe 유틸리티 함수 생성 (`utils/nullSafe.ts`)
- `safeString()`: null/undefined를 안전하게 문자열로 변환
- `safeStringWithLength()`: 길이 제한 포함
- `firstValidString()`: 여러 값 중 첫 번째 유효한 값 반환 (fallback 체인)
- `validateInsertValues()`: INSERT 값 배열에서 NOT NULL 필드 강제 검증

### 2. 코드 리팩토링
- 중복된 null 체크 로직을 유틸리티 함수로 통합
- 값 처리 로직을 단순화하고 명확하게 만듦
- 검증 로직을 한 곳에 집중

### 3. 검증 강화
- INSERT 직전에 `validateInsertValues()` 함수로 NOT NULL 필드 강제 검증
- 배열 인덱스를 직접 지정하여 정확한 필드 검증

## 개선 효과

1. **코드 간결성**: 중복 코드 제거로 가독성 향상
2. **유지보수성**: null 처리 로직이 한 곳에 집중되어 수정 용이
3. **안정성**: 검증 로직이 강화되어 오류 발생 가능성 감소
4. **재사용성**: 다른 곳에서도 null-safe 유틸리티 함수 사용 가능

## 향후 방지책

1. **코드 리뷰**: null 처리 로직이 유틸리티 함수를 사용하는지 확인
2. **테스트**: null 값이 포함된 다양한 케이스 테스트
3. **타입 안정성**: TypeScript의 strict null checks 활용
4. **문서화**: null-safe 유틸리티 함수 사용법 문서화

